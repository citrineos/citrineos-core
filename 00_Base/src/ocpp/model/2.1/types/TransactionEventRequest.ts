// SPDX-FileCopyrightText: 2025 Contributors to the CitrineOS Project
//
// SPDX-License-Identifier: Apache-2.0

/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

import {
  ChargingStateEnumType,
  CostDimensionEnumType,
  LocationEnumType,
  MeasurandEnumType,
  OperationModeEnumType,
  PhaseEnumType,
  PreconditioningStatusEnumType,
  ReadingContextEnumType,
  ReasonEnumType,
  TariffCostEnumType,
  TransactionEventEnumType,
  TriggerReasonEnumType,
} from '../enums/index.js';
import type { OcppRequest } from '../../../../index.js';

export interface TransactionEventRequest extends OcppRequest {
  costDetails?: CostDetailsType | null;
  eventType: TransactionEventEnumType;
  /**
   * @minItems 1
   */
  meterValue?: [MeterValueType, ...MeterValueType[]] | null;
  /**
   * The date and time at which this transaction event occurred.
   *
   */
  timestamp: string;
  triggerReason: TriggerReasonEnumType;
  /**
   * Incremental sequence number, helps with determining if all messages of a transaction have been received.
   *
   */
  seqNo: number;
  /**
   * Indication that this transaction event happened when the Charging Station was offline. Default = false, meaning: the event occurred when the Charging Station was online.
   *
   */
  offline?: boolean | null;
  /**
   * If the Charging Station is able to report the number of phases used, then it SHALL provide it.
   * When omitted the CSMS may be able to determine the number of phases used as follows: +
   * 1: The numberPhases in the currently used ChargingSchedule. +
   * 2: The number of phases provided via device management.
   *
   */
  numberOfPhasesUsed?: number | null;
  /**
   * The maximum current of the connected cable in Ampere (A).
   *
   */
  cableMaxCurrent?: number | null;
  /**
   * This contains the Id of the reservation that terminates as a result of this transaction.
   *
   */
  reservationId?: number | null;
  preconditioningStatus?: PreconditioningStatusEnumType | null;
  /**
   * *(2.1)* True when EVSE electronics are in sleep mode for this transaction. Default value (when absent) is false.
   *
   *
   */
  evseSleep?: boolean | null;
  transactionInfo: TransactionType;
  evse?: EVSEType | null;
  idToken?: IdTokenType | null;
  customData?: CustomDataType | null;
}
/**
 * CostDetailsType contains the cost as calculated by Charging Station based on provided TariffType.
 *
 * NOTE: Reservation is not shown as a _chargingPeriod_, because it took place outside of the transaction.
 *
 *
 */
export interface CostDetailsType {
  /**
   * @minItems 1
   */
  chargingPeriods?: [ChargingPeriodType, ...ChargingPeriodType[]] | null;
  totalCost: TotalCostType;
  totalUsage: TotalUsageType;
  /**
   * If set to true, then Charging Station has failed to calculate the cost.
   *
   *
   */
  failureToCalculate?: boolean | null;
  /**
   * Optional human-readable reason text in case of failure to calculate.
   *
   *
   */
  failureReason?: string | null;
  customData?: CustomDataType | null;
}
/**
 * A ChargingPeriodType consists of a start time, and a list of possible values that influence this period, for example: amount of energy charged this period, maximum current during this period etc.
 *
 *
 */
export interface ChargingPeriodType {
  /**
   * @minItems 1
   */
  dimensions?: [CostDimensionType, ...CostDimensionType[]] | null;
  /**
   * Unique identifier of the Tariff that was used to calculate cost. If not provided, then cost was calculated by some other means.
   *
   *
   */
  tariffId?: string | null;
  /**
   * Start timestamp of charging period. A period ends when the next period starts. The last period ends when the session ends.
   *
   *
   */
  startPeriod: string;
  customData?: CustomDataType | null;
}
/**
 * Volume consumed of cost dimension.
 *
 */
export interface CostDimensionType {
  type: CostDimensionEnumType;
  /**
   * Volume of the dimension consumed, measured according to the dimension type.
   *
   *
   */
  volume: number;
  customData?: CustomDataType | null;
}
/**
 * This class does not get 'AdditionalProperties = false' in the schema generation, so it can be extended with arbitrary JSON properties to allow adding custom data.
 */
export interface CustomDataType {
  vendorId: string;
  [k: string]: unknown;
}
/**
 * This contains the cost calculated during a transaction. It is used both for running cost and final cost of the transaction.
 *
 */
export interface TotalCostType {
  /**
   * Currency of the costs in ISO 4217 Code.
   *
   *
   */
  currency: string;
  typeOfCost: TariffCostEnumType;
  fixed?: PriceType | null;
  energy?: PriceType | null;
  chargingTime?: PriceType | null;
  idleTime?: PriceType | null;
  reservationTime?: PriceType | null;
  reservationFixed?: PriceType | null;
  total: TotalPriceType;
  customData?: CustomDataType | null;
}
/**
 * Price with and without tax. At least one of _exclTax_, _inclTax_ must be present.
 *
 */
export interface PriceType {
  /**
   * Price/cost excluding tax. Can be absent if _inclTax_ is present.
   *
   */
  exclTax?: number | null;
  /**
   * Price/cost including tax. Can be absent if _exclTax_ is present.
   *
   */
  inclTax?: number | null;
  /**
   * @minItems 1
   * @maxItems 5
   */
  taxRates?:
    | [TaxRateType]
    | [TaxRateType, TaxRateType]
    | [TaxRateType, TaxRateType, TaxRateType]
    | [TaxRateType, TaxRateType, TaxRateType, TaxRateType]
    | [TaxRateType, TaxRateType, TaxRateType, TaxRateType, TaxRateType]
    | null;
  customData?: CustomDataType | null;
}
/**
 * Tax percentage
 *
 */
export interface TaxRateType {
  /**
   * Type of this tax, e.g.  "Federal ",  "State", for information on receipt.
   *
   */
  type: string;
  /**
   * Tax percentage
   *
   */
  tax: number;
  /**
   * Stack level for this type of tax. Default value, when absent, is 0. +
   * _stack_ = 0: tax on net price; +
   * _stack_ = 1: tax added on top of _stack_ 0; +
   * _stack_ = 2: tax added on top of _stack_ 1, etc.
   *
   */
  stack?: number | null;
  customData?: CustomDataType | null;
}
/**
 * Total cost with and without tax. Contains the total of energy, charging time, idle time, fixed and reservation costs including and/or excluding tax.
 *
 */
export interface TotalPriceType {
  /**
   * Price/cost excluding tax. Can be absent if _inclTax_ is present.
   *
   */
  exclTax?: number | null;
  /**
   * Price/cost including tax. Can be absent if _exclTax_ is present.
   *
   */
  inclTax?: number | null;
  customData?: CustomDataType | null;
}
/**
 * This contains the calculated usage of energy, charging time and idle time during a transaction.
 *
 */
export interface TotalUsageType {
  energy: number;
  /**
   * Total duration of the charging session (including the duration of charging and not charging), in seconds.
   *
   *
   *
   */
  chargingTime: number;
  /**
   * Total duration of the charging session where the EV was not charging (no energy was transferred between EVSE and EV), in seconds.
   *
   *
   *
   */
  idleTime: number;
  /**
   * Total time of reservation in seconds.
   *
   */
  reservationTime?: number | null;
  customData?: CustomDataType | null;
}
/**
 * Collection of one or more sampled values in MeterValuesRequest and TransactionEvent. All sampled values in a MeterValue are sampled at the same point in time.
 *
 */
export interface MeterValueType {
  /**
   * @minItems 1
   */
  sampledValue: [SampledValueType, ...SampledValueType[]];
  /**
   * Timestamp for measured value(s).
   *
   */
  timestamp: string;
  customData?: CustomDataType | null;
}
/**
 * Single sampled value in MeterValues. Each value can be accompanied by optional fields.
 *
 * To save on mobile data usage, default values of all of the optional fields are such that. The value without any additional fields will be interpreted, as a register reading of active import energy in Wh (Watt-hour) units.
 *
 */
export interface SampledValueType {
  /**
   * Indicates the measured value.
   *
   *
   */
  value: number;
  measurand?: MeasurandEnumType | null;
  context?: ReadingContextEnumType | null;
  phase?: PhaseEnumType | null;
  location?: LocationEnumType | null;
  signedMeterValue?: SignedMeterValueType | null;
  unitOfMeasure?: UnitOfMeasureType | null;
  customData?: CustomDataType | null;
}
/**
 * Represent a signed version of the meter value.
 *
 */
export interface SignedMeterValueType {
  /**
   * Base64 encoded, contains the signed data from the meter in the format specified in _encodingMethod_, which might contain more then just the meter value. It can contain information like timestamps, reference to a customer etc.
   *
   */
  signedMeterData: string;
  /**
   * *(2.1)* Method used to create the digital signature. Optional, if already included in _signedMeterData_. Standard values for this are defined in Appendix as SigningMethodEnumStringType.
   *
   */
  signingMethod?: string | null;
  /**
   * Format used by the energy meter to encode the meter data. For example: OCMF or EDL.
   *
   */
  encodingMethod: string;
  /**
   * *(2.1)* Base64 encoded, sending depends on configuration variable _PublicKeyWithSignedMeterValue_.
   *
   */
  publicKey?: string | null;
  customData?: CustomDataType | null;
}
/**
 * Represents a UnitOfMeasure with a multiplier
 *
 */
export interface UnitOfMeasureType {
  /**
   * Unit of the value. Default = "Wh" if the (default) measurand is an "Energy" type.
   * This field SHALL use a value from the list Standardized Units of Measurements in Part 2 Appendices.
   * If an applicable unit is available in that list, otherwise a "custom" unit might be used.
   *
   */
  unit?: string | null;
  /**
   * Multiplier, this value represents the exponent to base 10. I.e. multiplier 3 means 10 raised to the 3rd power. Default is 0. +
   * The _multiplier_ only multiplies the value of the measurand. It does not specify a conversion between units, for example, kW and W.
   *
   */
  multiplier?: number | null;
  customData?: CustomDataType | null;
}
export interface TransactionType {
  /**
   * This contains the Id of the transaction.
   *
   */
  transactionId: string;
  chargingState?: ChargingStateEnumType | null;
  /**
   * Contains the total time that energy flowed from EVSE to EV during the transaction (in seconds). Note that timeSpentCharging is smaller or equal to the duration of the transaction.
   *
   */
  timeSpentCharging?: number | null;
  stoppedReason?: ReasonEnumType | null;
  /**
   * The ID given to remote start request (&lt;&lt;requeststarttransactionrequest, RequestStartTransactionRequest&gt;&gt;. This enables to CSMS to match the started transaction to the given start request.
   *
   */
  remoteStartId?: number | null;
  operationMode?: OperationModeEnumType | null;
  /**
   * *(2.1)* Id of tariff in use for transaction
   *
   */
  tariffId?: string | null;
  transactionLimit?: TransactionLimitType | null;
  customData?: CustomDataType | null;
}
/**
 * Cost, energy, time or SoC limit for a transaction.
 *
 */
export interface TransactionLimitType {
  /**
   * Maximum allowed cost of transaction in currency of tariff.
   *
   */
  maxCost?: number | null;
  /**
   * Maximum allowed energy in Wh to charge in transaction.
   *
   */
  maxEnergy?: number | null;
  /**
   * Maximum duration of transaction in seconds from start to end.
   *
   */
  maxTime?: number | null;
  /**
   * Maximum State of Charge of EV in percentage.
   *
   */
  maxSoC?: number | null;
  customData?: CustomDataType | null;
}
/**
 * Electric Vehicle Supply Equipment
 *
 */
export interface EVSEType {
  /**
   * EVSE Identifier. This contains a number (&gt; 0) designating an EVSE of the Charging Station.
   *
   */
  id: number;
  /**
   * An id to designate a specific connector (on an EVSE) by connector index number.
   *
   */
  connectorId?: number | null;
  customData?: CustomDataType | null;
}
/**
 * Contains a case insensitive identifier to use for the authorization and the type of authorization to support multiple forms of identifiers.
 *
 */
export interface IdTokenType {
  /**
   * @minItems 1
   */
  additionalInfo?: [AdditionalInfoType, ...AdditionalInfoType[]] | null;
  /**
   * *(2.1)* IdToken is case insensitive. Might hold the hidden id of an RFID tag, but can for example also contain a UUID.
   *
   */
  idToken: string;
  /**
   * *(2.1)* Enumeration of possible idToken types. Values defined in Appendix as IdTokenEnumStringType.
   *
   */
  type: string;
  customData?: CustomDataType | null;
}
/**
 * Contains a case insensitive identifier to use for the authorization and the type of authorization to support multiple forms of identifiers.
 *
 */
export interface AdditionalInfoType {
  /**
   * *(2.1)* This field specifies the additional IdToken.
   *
   */
  additionalIdToken: string;
  /**
   * _additionalInfo_ can be used to send extra information to CSMS in addition to the regular authorization with _IdToken_. _AdditionalInfo_ contains one or more custom _types_, which need to be agreed upon by all parties involved. When the _type_ is not supported, the CSMS/Charging Station MAY ignore the _additionalInfo_.
   *
   *
   */
  type: string;
  customData?: CustomDataType | null;
}
