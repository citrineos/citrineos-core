// SPDX-FileCopyrightText: 2025 Contributors to the CitrineOS Project
//
// SPDX-License-Identifier: Apache-2.0

/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

import { DayOfWeekEnumType, EvseKindEnumType, MessageFormatEnumType } from '../enums/index.js';
import type { OcppRequest } from '../../../../index.js';

export interface ChangeTransactionTariffRequest extends OcppRequest {
  tariff: TariffType;
  /**
   * Transaction id for new tariff.
   *
   */
  transactionId: string;
  customData?: CustomDataType | null;
}
/**
 * A tariff is described by fields with prices for:
 * energy,
 * charging time,
 * idle time,
 * fixed fee,
 * reservation time,
 * reservation fixed fee. +
 * Each of these fields may have (optional) conditions that specify when a price is applicable. +
 * The _description_ contains a human-readable explanation of the tariff to be shown to the user. +
 * The other fields are parameters that define the tariff. These are used by the charging station to calculate the price.
 *
 */
export interface TariffType {
  /**
   * Unique id of tariff
   *
   */
  tariffId: string;
  /**
   * @minItems 1
   * @maxItems 10
   */
  description?:
    | [MessageContentType]
    | [MessageContentType, MessageContentType]
    | [MessageContentType, MessageContentType, MessageContentType]
    | [MessageContentType, MessageContentType, MessageContentType, MessageContentType]
    | [
        MessageContentType,
        MessageContentType,
        MessageContentType,
        MessageContentType,
        MessageContentType,
      ]
    | [
        MessageContentType,
        MessageContentType,
        MessageContentType,
        MessageContentType,
        MessageContentType,
        MessageContentType,
      ]
    | [
        MessageContentType,
        MessageContentType,
        MessageContentType,
        MessageContentType,
        MessageContentType,
        MessageContentType,
        MessageContentType,
      ]
    | [
        MessageContentType,
        MessageContentType,
        MessageContentType,
        MessageContentType,
        MessageContentType,
        MessageContentType,
        MessageContentType,
        MessageContentType,
      ]
    | [
        MessageContentType,
        MessageContentType,
        MessageContentType,
        MessageContentType,
        MessageContentType,
        MessageContentType,
        MessageContentType,
        MessageContentType,
        MessageContentType,
      ]
    | [
        MessageContentType,
        MessageContentType,
        MessageContentType,
        MessageContentType,
        MessageContentType,
        MessageContentType,
        MessageContentType,
        MessageContentType,
        MessageContentType,
        MessageContentType,
      ]
    | null;
  /**
   * Currency code according to ISO 4217
   *
   */
  currency: string;
  energy?: TariffEnergyType | null;
  /**
   * Time when this tariff becomes active. When absent, it is immediately active.
   *
   */
  validFrom?: string | null;
  chargingTime?: TariffTimeType | null;
  idleTime?: TariffTimeType | null;
  fixedFee?: TariffFixedType | null;
  reservationTime?: TariffTimeType | null;
  reservationFixed?: TariffFixedType | null;
  minCost?: PriceType | null;
  maxCost?: PriceType | null;
  customData?: CustomDataType | null;
}
/**
 * Contains message details, for a message to be displayed on a Charging Station.
 *
 *
 */
export interface MessageContentType {
  format: MessageFormatEnumType;
  /**
   * Message language identifier. Contains a language code as defined in &lt;&lt;ref-RFC5646,[RFC5646]&gt;&gt;.
   *
   */
  language?: string | null;
  /**
   * *(2.1)* Required. Message contents. +
   * Maximum length supported by Charging Station is given in OCPPCommCtrlr.FieldLength["MessageContentType.content"].
   *     Maximum length defaults to 1024.
   *
   *
   */
  content: string;
  customData?: CustomDataType | null;
}
/**
 * This class does not get 'AdditionalProperties = false' in the schema generation, so it can be extended with arbitrary JSON properties to allow adding custom data.
 */
export interface CustomDataType {
  vendorId: string;
  [k: string]: unknown;
}
/**
 * Price elements and tax for energy
 *
 */
export interface TariffEnergyType {
  /**
   * @minItems 1
   */
  prices: [TariffEnergyPriceType, ...TariffEnergyPriceType[]];
  /**
   * @minItems 1
   * @maxItems 5
   */
  taxRates?:
    | [TaxRateType]
    | [TaxRateType, TaxRateType]
    | [TaxRateType, TaxRateType, TaxRateType]
    | [TaxRateType, TaxRateType, TaxRateType, TaxRateType]
    | [TaxRateType, TaxRateType, TaxRateType, TaxRateType, TaxRateType]
    | null;
  customData?: CustomDataType | null;
}
/**
 * Tariff with optional conditions for an energy price.
 *
 */
export interface TariffEnergyPriceType {
  /**
   * Price per kWh (excl. tax) for this element.
   *
   */
  priceKwh: number;
  conditions?: TariffConditionsType | null;
  customData?: CustomDataType | null;
}
/**
 * These conditions describe if and when a TariffEnergyType or TariffTimeType applies during a transaction.
 *
 * When more than one restriction is set, they are to be treated as a logical AND. All need to be valid before this price is active.
 *
 * For reverse energy flow (discharging) negative values of energy, power and current are used.
 *
 * NOTE: _minXXX_ (where XXX = Kwh/A/Kw) must be read as "closest to zero", and _maxXXX_ as "furthest from zero". For example, a *charging* power range from 10 kW to 50 kWh is given by _minPower_ = 10000 and _maxPower_ = 50000, and a *discharging* power range from -10 kW to -50 kW is given by _minPower_ = -10 and _maxPower_ = -50.
 *
 * NOTE: _startTimeOfDay_ and _endTimeOfDay_ are in local time, because it is the time in the tariff as it is shown to the EV driver at the Charging Station.
 * A Charging Station will convert this to the internal time zone that it uses (which is recommended to be UTC, see section Generic chapter 3.1) when performing cost calculation.
 *
 *
 */
export interface TariffConditionsType {
  /**
   * Start time of day in local time. +
   * Format as per RFC 3339: time-hour ":" time-minute  +
   * Must be in 24h format with leading zeros. Hour/Minute separator: ":"
   * Regex: ([0-1][0-9]\|2[0-3]):[0-5][0-9]
   *
   */
  startTimeOfDay?: string | null;
  /**
   * End time of day in local time. Same syntax as _startTimeOfDay_. +
   *     If end time &lt; start time then the period wraps around to the next day. +
   *     To stop at end of the day use: 00:00.
   *
   */
  endTimeOfDay?: string | null;
  /**
   * Day(s) of the week this is tariff applies.
   *
   *
   * @minItems 1
   * @maxItems 7
   */
  dayOfWeek?:
    | [DayOfWeekEnumType]
    | [DayOfWeekEnumType, DayOfWeekEnumType]
    | [DayOfWeekEnumType, DayOfWeekEnumType, DayOfWeekEnumType]
    | [DayOfWeekEnumType, DayOfWeekEnumType, DayOfWeekEnumType, DayOfWeekEnumType]
    | [
        DayOfWeekEnumType,
        DayOfWeekEnumType,
        DayOfWeekEnumType,
        DayOfWeekEnumType,
        DayOfWeekEnumType,
      ]
    | [
        DayOfWeekEnumType,
        DayOfWeekEnumType,
        DayOfWeekEnumType,
        DayOfWeekEnumType,
        DayOfWeekEnumType,
        DayOfWeekEnumType,
      ]
    | [
        DayOfWeekEnumType,
        DayOfWeekEnumType,
        DayOfWeekEnumType,
        DayOfWeekEnumType,
        DayOfWeekEnumType,
        DayOfWeekEnumType,
        DayOfWeekEnumType,
      ]
    | null;
  /**
   * Start date in local time, for example: 2015-12-24.
   * Valid from this day (inclusive). +
   * Format as per RFC 3339: full-date  +
   *
   * Regex: ([12][0-9]{3})-(0[1-9]\|1[0-2])-(0[1-9]\|[12][0-9]\|3[01])
   *
   */
  validFromDate?: string | null;
  /**
   * End date in local time, for example: 2015-12-27.
   *     Valid until this day (exclusive). Same syntax as _validFromDate_.
   *
   */
  validToDate?: string | null;
  evseKind?: EvseKindEnumType | null;
  /**
   * Minimum consumed energy in Wh, for example 20000 Wh.
   *     Valid from this amount of energy (inclusive) being used.
   *
   */
  minEnergy?: number | null;
  /**
   * Maximum consumed energy in Wh, for example 50000 Wh.
   *     Valid until this amount of energy (exclusive) being used.
   *
   */
  maxEnergy?: number | null;
  /**
   * Sum of the minimum current (in Amperes) over all phases, for example 5 A.
   *     When the EV is charging with more than, or equal to, the defined amount of current, this price is/becomes active. If the charging current is or becomes lower, this price is not or no longer valid and becomes inactive. +
   *     This is NOT about the minimum current over the entire transaction.
   *
   */
  minCurrent?: number | null;
  /**
   * Sum of the maximum current (in Amperes) over all phases, for example 20 A.
   *       When the EV is charging with less than the defined amount of current, this price becomes/is active. If the charging current is or becomes higher, this price is not or no longer valid and becomes inactive.
   *       This is NOT about the maximum current over the entire transaction.
   *
   */
  maxCurrent?: number | null;
  /**
   * Minimum power in W, for example 5000 W.
   *       When the EV is charging with more than, or equal to, the defined amount of power, this price is/becomes active.
   *       If the charging power is or becomes lower, this price is not or no longer valid and becomes inactive.
   *       This is NOT about the minimum power over the entire transaction.
   *
   */
  minPower?: number | null;
  /**
   * Maximum power in W, for example 20000 W.
   *       When the EV is charging with less than the defined amount of power, this price becomes/is active.
   *       If the charging power is or becomes higher, this price is not or no longer valid and becomes inactive.
   *       This is NOT about the maximum power over the entire transaction.
   *
   */
  maxPower?: number | null;
  /**
   * Minimum duration in seconds the transaction (charging &amp; idle) MUST last (inclusive).
   *       When the duration of a transaction is longer than the defined value, this price is or becomes active.
   *       Before that moment, this price is not yet active.
   *
   */
  minTime?: number | null;
  /**
   * Maximum duration in seconds the transaction (charging &amp; idle) MUST last (exclusive).
   *       When the duration of a transaction is shorter than the defined value, this price is or becomes active.
   *       After that moment, this price is no longer active.
   *
   */
  maxTime?: number | null;
  /**
   * Minimum duration in seconds the charging MUST last (inclusive).
   *       When the duration of a charging is longer than the defined value, this price is or becomes active.
   *       Before that moment, this price is not yet active.
   *
   */
  minChargingTime?: number | null;
  /**
   * Maximum duration in seconds the charging MUST last (exclusive).
   *       When the duration of a charging is shorter than the defined value, this price is or becomes active.
   *       After that moment, this price is no longer active.
   *
   */
  maxChargingTime?: number | null;
  /**
   * Minimum duration in seconds the idle period (i.e. not charging) MUST last (inclusive).
   *       When the duration of the idle time is longer than the defined value, this price is or becomes active.
   *       Before that moment, this price is not yet active.
   *
   */
  minIdleTime?: number | null;
  /**
   * Maximum duration in seconds the idle period (i.e. not charging) MUST last (exclusive).
   *       When the duration of idle time is shorter than the defined value, this price is or becomes active.
   *       After that moment, this price is no longer active.
   *
   */
  maxIdleTime?: number | null;
  customData?: CustomDataType | null;
}
/**
 * Tax percentage
 *
 */
export interface TaxRateType {
  /**
   * Type of this tax, e.g.  "Federal ",  "State", for information on receipt.
   *
   */
  type: string;
  /**
   * Tax percentage
   *
   */
  tax: number;
  /**
   * Stack level for this type of tax. Default value, when absent, is 0. +
   * _stack_ = 0: tax on net price; +
   * _stack_ = 1: tax added on top of _stack_ 0; +
   * _stack_ = 2: tax added on top of _stack_ 1, etc.
   *
   */
  stack?: number | null;
  customData?: CustomDataType | null;
}
/**
 * Price elements and tax for time
 *
 *
 */
export interface TariffTimeType {
  /**
   * @minItems 1
   */
  prices: [TariffTimePriceType, ...TariffTimePriceType[]];
  /**
   * @minItems 1
   * @maxItems 5
   */
  taxRates?:
    | [TaxRateType]
    | [TaxRateType, TaxRateType]
    | [TaxRateType, TaxRateType, TaxRateType]
    | [TaxRateType, TaxRateType, TaxRateType, TaxRateType]
    | [TaxRateType, TaxRateType, TaxRateType, TaxRateType, TaxRateType]
    | null;
  customData?: CustomDataType | null;
}
/**
 * Tariff with optional conditions for a time duration price.
 *
 */
export interface TariffTimePriceType {
  /**
   * Price per minute (excl. tax) for this element.
   *
   */
  priceMinute: number;
  conditions?: TariffConditionsType | null;
  customData?: CustomDataType | null;
}
export interface TariffFixedType {
  /**
   * @minItems 1
   */
  prices: [TariffFixedPriceType, ...TariffFixedPriceType[]];
  /**
   * @minItems 1
   * @maxItems 5
   */
  taxRates?:
    | [TaxRateType]
    | [TaxRateType, TaxRateType]
    | [TaxRateType, TaxRateType, TaxRateType]
    | [TaxRateType, TaxRateType, TaxRateType, TaxRateType]
    | [TaxRateType, TaxRateType, TaxRateType, TaxRateType, TaxRateType]
    | null;
  customData?: CustomDataType | null;
}
/**
 * Tariff with optional conditions for a fixed price.
 *
 */
export interface TariffFixedPriceType {
  conditions?: TariffConditionsFixedType | null;
  /**
   * Fixed price  for this element e.g. a start fee.
   *
   */
  priceFixed: number;
  customData?: CustomDataType | null;
}
/**
 * These conditions describe if a FixedPrice applies at start of the transaction.
 *
 * When more than one restriction is set, they are to be treated as a logical AND. All need to be valid before this price is active.
 *
 * NOTE: _startTimeOfDay_ and _endTimeOfDay_ are in local time, because it is the time in the tariff as it is shown to the EV driver at the Charging Station.
 * A Charging Station will convert this to the internal time zone that it uses (which is recommended to be UTC, see section Generic chapter 3.1) when performing cost calculation.
 *
 *
 */
export interface TariffConditionsFixedType {
  /**
   * Start time of day in local time. +
   * Format as per RFC 3339: time-hour ":" time-minute  +
   * Must be in 24h format with leading zeros. Hour/Minute separator: ":"
   * Regex: ([0-1][0-9]\|2[0-3]):[0-5][0-9]
   *
   */
  startTimeOfDay?: string | null;
  /**
   * End time of day in local time. Same syntax as _startTimeOfDay_. +
   *     If end time &lt; start time then the period wraps around to the next day. +
   *     To stop at end of the day use: 00:00.
   *
   */
  endTimeOfDay?: string | null;
  /**
   * Day(s) of the week this is tariff applies.
   *
   *
   * @minItems 1
   * @maxItems 7
   */
  dayOfWeek?:
    | [DayOfWeekEnumType]
    | [DayOfWeekEnumType, DayOfWeekEnumType]
    | [DayOfWeekEnumType, DayOfWeekEnumType, DayOfWeekEnumType]
    | [DayOfWeekEnumType, DayOfWeekEnumType, DayOfWeekEnumType, DayOfWeekEnumType]
    | [
        DayOfWeekEnumType,
        DayOfWeekEnumType,
        DayOfWeekEnumType,
        DayOfWeekEnumType,
        DayOfWeekEnumType,
      ]
    | [
        DayOfWeekEnumType,
        DayOfWeekEnumType,
        DayOfWeekEnumType,
        DayOfWeekEnumType,
        DayOfWeekEnumType,
        DayOfWeekEnumType,
      ]
    | [
        DayOfWeekEnumType,
        DayOfWeekEnumType,
        DayOfWeekEnumType,
        DayOfWeekEnumType,
        DayOfWeekEnumType,
        DayOfWeekEnumType,
        DayOfWeekEnumType,
      ]
    | null;
  /**
   * Start date in local time, for example: 2015-12-24.
   * Valid from this day (inclusive). +
   * Format as per RFC 3339: full-date  +
   *
   * Regex: ([12][0-9]{3})-(0[1-9]\|1[0-2])-(0[1-9]\|[12][0-9]\|3[01])
   *
   */
  validFromDate?: string | null;
  /**
   * End date in local time, for example: 2015-12-27.
   *     Valid until this day (exclusive). Same syntax as _validFromDate_.
   *
   */
  validToDate?: string | null;
  evseKind?: EvseKindEnumType | null;
  /**
   * For which payment brand this (adhoc) tariff applies. Can be used to add a surcharge for certain payment brands.
   *     Based on value of _additionalIdToken_ from _idToken.additionalInfo.type_ = "PaymentBrand".
   *
   */
  paymentBrand?: string | null;
  /**
   * Type of adhoc payment, e.g. CC, Debit.
   *     Based on value of _additionalIdToken_ from _idToken.additionalInfo.type_ = "PaymentRecognition".
   *
   */
  paymentRecognition?: string | null;
  customData?: CustomDataType | null;
}
/**
 * Price with and without tax. At least one of _exclTax_, _inclTax_ must be present.
 *
 */
export interface PriceType {
  /**
   * Price/cost excluding tax. Can be absent if _inclTax_ is present.
   *
   */
  exclTax?: number | null;
  /**
   * Price/cost including tax. Can be absent if _exclTax_ is present.
   *
   */
  inclTax?: number | null;
  /**
   * @minItems 1
   * @maxItems 5
   */
  taxRates?:
    | [TaxRateType]
    | [TaxRateType, TaxRateType]
    | [TaxRateType, TaxRateType, TaxRateType]
    | [TaxRateType, TaxRateType, TaxRateType, TaxRateType]
    | [TaxRateType, TaxRateType, TaxRateType, TaxRateType, TaxRateType]
    | null;
  customData?: CustomDataType | null;
}
